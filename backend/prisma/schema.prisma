// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Modelo de Country/Barrio
model Country {
  id        String   @id @default(cuid())
  name      String
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  vecinos  Vecino[]
  periodos Periodo[]

  @@map("countries")
}

// Modelo de Vecino
model Vecino {
  id        String  @id @default(cuid())
  countryId String
  country   Country @relation(fields: [countryId], references: [id], onDelete: Cascade)

  nombre        String
  apellido      String
  email         String
  telefono      String?
  unidad        String? // Ej: "Casa 12", "Lote 5"
  observaciones String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  expensas     Expensa[]
  comprobantes Comprobante[]
  mensajes     Mensaje[]
  pagos        Pago[]

  @@map("vecinos")
}

// Modelo de Período (mes/año de expensas)
model Periodo {
  id        String  @id @default(cuid())
  countryId String
  country   Country @relation(fields: [countryId], references: [id], onDelete: Cascade)

  mes              Int // 1-12
  anio             Int
  montoBase        Decimal   @db.Decimal(10, 2)
  fechaVencimiento DateTime
  fechaCierre      DateTime?

  // Configuración de cronjobs y automatización
  diasRecordatorioAntes  Int     @default(3) // Días antes del vencimiento para enviar recordatorios
  diasMora               Int     @default(1) // Días después del vencimiento para cambiar a EN_MORA
  frecuenciaSeguimiento  Int     @default(7) // Cada cuántos días enviar seguimientos (en mora)
  maxSeguimientos        Int     @default(3) // Máximo de seguimientos antes de cambiar a EN_RECUPERO
  canalesRecordatorio    String  @default("WHATSAPP") // Canales para recordatorios: WHATSAPP,EMAIL o ambos separados por coma
  canalesSeguimiento     String  @default("WHATSAPP") // Canales para seguimientos: WHATSAPP,EMAIL o ambos separados por coma
  habilitarRecordatorios Boolean @default(true) // Habilitar recordatorios automáticos
  habilitarSeguimientos  Boolean @default(true) // Habilitar seguimientos automáticos

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  expensas Expensa[]

  @@unique([countryId, mes, anio])
  @@map("periodos")
}

// Modelo de Expensa (expensa individual por vecino)
model Expensa {
  id        String  @id @default(cuid())
  periodoId String
  periodo   Periodo @relation(fields: [periodoId], references: [id], onDelete: Cascade)
  vecinoId  String
  vecino    Vecino  @relation(fields: [vecinoId], references: [id], onDelete: Cascade)

  monto  Decimal       @db.Decimal(10, 2)
  estado EstadoExpensa @default(PENDIENTE)

  // Fechas de seguimiento
  fechaVencimiento       DateTime
  fechaUltimoSeguimiento DateTime?
  proximoSeguimiento     DateTime?

  // Contador de seguimientos
  contadorSeguimientos Int @default(0)

  // Mes de mora (null si no está en mora)
  mesMora Int?

  // Boleta/Factura asociada
  boletaUrl           String? // URL del archivo de boleta almacenado
  boletaNombreArchivo String? // Nombre original del archivo
  boletaTipoArchivo   String? // Tipo MIME (application/pdf, image/jpeg, etc.)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mensajes     Mensaje[]
  comprobantes Comprobante[]
  pagos        Pago[]

  @@unique([periodoId, vecinoId])
  @@map("expensas")
}

// Estados operativos de expensas
enum EstadoExpensa {
  PENDIENTE
  PAGO_INFORMADO
  CONFIRMADO
  EN_MORA
  EN_RECUPERO
  SIN_RESPUESTA
  PAUSADO
}

// Modelo de Mensaje (comunicaciones)
model Mensaje {
  id        String   @id @default(cuid())
  expensaId String?
  expensa   Expensa? @relation(fields: [expensaId], references: [id], onDelete: SetNull)
  vecinoId  String
  vecino    Vecino   @relation(fields: [vecinoId], references: [id], onDelete: Cascade)

  canal     CanalMensaje
  tipo      TipoMensaje
  contenido String?
  estado    EstadoMensaje @default(ENVIADO)

  // Para WhatsApp
  whatsappId String?

  // Para Email
  emailId String?
  asunto  String?

  createdAt DateTime @default(now())

  @@map("mensajes")
}

enum CanalMensaje {
  WHATSAPP
  EMAIL
}

enum TipoMensaje {
  EMISION
  RECORDATORIO_VENCIMIENTO
  SEGUIMIENTO
  CIERRE_MES
  MORA
  RECUPERO
  MANUAL
}

enum EstadoMensaje {
  ENVIADO
  ENTREGADO
  LEIDO
  ERROR
}

// Modelo de Comprobante
model Comprobante {
  id        String   @id @default(cuid())
  expensaId String?
  expensa   Expensa? @relation(fields: [expensaId], references: [id], onDelete: SetNull)
  vecinoId  String
  vecino    Vecino   @relation(fields: [vecinoId], references: [id], onDelete: Cascade)

  url           String // URL del archivo almacenado
  tipoArchivo   String // image/jpeg, application/pdf, etc.
  nombreArchivo String

  estado        EstadoComprobante @default(NUEVO)
  observaciones String?

  // Relación con Pago (si viene del concentrador)
  pago Pago?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("comprobantes")
}

enum EstadoComprobante {
  NUEVO
  REVISADO
  CONFIRMADO
  RECHAZADO
}

// Modelo de Pago (pagos del concentrador para conciliación)
model Pago {
  id String @id @default(cuid())

  // Datos del pago del concentrador
  monto            Decimal  @db.Decimal(10, 2)
  fecha            DateTime
  referencia       String? // Referencia del pago del concentrador
  nombre           String? // Nombre del pagador
  email            String? // Email del pagador
  telefono         String? // Teléfono del pagador
  descripcion      String? // Descripción del pago
  metodoPago       String? // Método de pago (TARJETA, TRANSFERENCIA, etc.)
  datosAdicionales String? // JSON con datos adicionales del concentrador

  // Conciliación
  vecinoId  String? // Vecino identificado (puede ser null si no se identificó)
  vecino    Vecino?  @relation(fields: [vecinoId], references: [id], onDelete: SetNull)
  expensaId String? // Expensa conciliada (puede ser null si no se concilió)
  expensa   Expensa? @relation(fields: [expensaId], references: [id], onDelete: SetNull)

  estado       EstadoPago        @default(PENDIENTE)
  confianza    Int? // Confianza de la conciliación automática (0-100)
  coincidencia TipoCoincidencia? // Tipo de coincidencia encontrada
  razon        String? // Razón de la conciliación o por qué no se concilió

  // Revisión manual
  revisadoPor   String? // ID del usuario que revisó manualmente
  fechaRevision DateTime?
  observaciones String?

  // Comprobante asociado (si se creó)
  comprobanteId String?      @unique
  comprobante   Comprobante? @relation(fields: [comprobanteId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("pagos")
}

enum EstadoPago {
  PENDIENTE // Pendiente de conciliación
  CONCILIADO // Conciliado automáticamente
  REVISADO // Revisado manualmente y confirmado
  RECHAZADO // Rechazado (no corresponde a ninguna expensa)
  DUPLICADO // Pago duplicado
}

enum TipoCoincidencia {
  EXACTA // Coincidencia exacta (monto, vecino, expensa)
  APROXIMADA // Coincidencia aproximada (monto similar)
  MANUAL // Requiere revisión manual
}

// Modelo de Usuario (administradores del sistema)
model Usuario {
  id           String @id @default(cuid())
  email        String @unique
  nombre       String
  passwordHash String

  rol    RolUsuario @default(OPERADOR)
  activo Boolean    @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("usuarios")
}

enum RolUsuario {
  ADMINISTRADOR
  OPERADOR
  LECTURA
}
